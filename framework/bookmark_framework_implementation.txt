class BookmarkManager {
    constructor(baseURL) {
        this.baseURL = baseURL;
        this.state = {
            currentDirectories: [],
            currentBookmarks: [],
            currentDirectoryId: null,
        };
    }

    // Action Interceptor
    actionInterceptor(action) {
        console.log('Dispatching action:', action);
        if (action.type === 'ADD_BOOKMARK') {
            action.timestamp = new Date();
        }
        return action;
    }

    // Dispatch Function
    dispatch(action) {
        const interceptedAction = this.actionInterceptor(action);
        this.handleAction(interceptedAction);
    }

    handleAction(action) {
        switch (action.type) {
            case 'SET_DIRECTORIES':
                this.setDirectories(action.payload);
                break;
            case 'SET_BOOKMARKS':
                this.setBookmarks(action.payload);
                break;
            case 'SET_CURRENT_DIRECTORY':
                this.setCurrentDirectory(action.payload);
                break;
            case 'ADD_BOOKMARK':
                this.addBookmark(action.payload);
                break;
            case 'DELETE_BOOKMARK':
                this.deleteBookmark(action.payload);
                break;
            default:
                console.warn('Unknown action type:', action.type);
        }
    }

    // Fetching Data
    async fetchData(endpoint, errorMessage) {
        try {
            const response = await fetch(`${this.baseURL}${endpoint}`);
            if (!response.ok) throw new Error(errorMessage);
            return await response.json();
        } catch (error) {
            console.error(error);
            alert(error.message); // Notify user of the error
        }
    }

    async fetchDirectories() {
        return this.fetchData('/api/directories', 'Failed to fetch directories');
    }

    async fetchBookmarks(directoryId) {
        return this.fetchData(`/api/bookmarks?directoryId=${directoryId}`, 'Failed to fetch bookmarks');
    }

    async addBookmark(bookmark) {
        return this.postData('/api/bookmarks', [bookmark], 'Failed to add bookmark');
    }

    async deleteBookmark(bookmarkId) {
        return this.deleteData(`/api/bookmarks/${bookmarkId}`, 'Failed to delete bookmark');
    }

    async moveBookmark(bookmarkId, newDirectoryId) {
        return this.postData('/api/bookmarks/move', { bookmark_id: bookmarkId, new_directory_id: newDirectoryId }, 'Failed to move bookmark');
    }

    async postData(endpoint, body, errorMessage) {
        try {
            const response = await fetch(`${this.baseURL}${endpoint}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
            });
            if (!response.ok) throw new Error(errorMessage);
            return await response.json();
        } catch (error) {
            console.error(error);
            alert(error.message);
        }
    }

    async deleteData(endpoint, errorMessage) {
        try {
            const response = await fetch(`${this.baseURL}${endpoint}`, { method: 'DELETE' });
            if (!response.ok) throw new Error(errorMessage);
            return await response.json();
        } catch (error) {
            console.error(error);
            alert(error.message);
        }
    }

    // State Management
    setDirectories(directories) {
        this.state.currentDirectories = directories;
        this.renderDirectories();
    }

    setBookmarks(bookmarks) {
        this.state.currentBookmarks = bookmarks;
        this.renderBookmarks();
    }

    setCurrentDirectory(directoryId) {
        this.state.currentDirectoryId = directoryId;
    }

    // Rendering Functions
    renderDirectories() {
        const directoryTree = document.getElementById('directory-tree');
        directoryTree.innerHTML = ''; // Clear existing directories
        this.state.currentDirectories.forEach(directory => {
            const directoryElement = this.createDraggableElement(directory.name, directory.id, () => {
                this.setCurrentDirectory(directory.id);
                this.loadBookmarks(directory.id);
            });
            directoryTree.appendChild(directoryElement);
        });
    }

    renderBookmarks() {
        const bookmarksArea = document.getElementById('bookmarks-area');
        bookmarksArea.innerHTML = ''; // Clear existing bookmarks
        this.state.currentBookmarks.forEach(bookmark => {
            const bookmarkElement = this.createDraggableBookmarkElement(bookmark);
            bookmarksArea.appendChild (bookmarkElement);
        });
    }

    // Create Elements
    createDraggableElement(name, id, clickHandler) {
        const element = document.createElement('div');
        element.textContent = name;
        element.dataset.id = id;
        element.draggable = true;
        element.addEventListener('click', clickHandler);
        return element;
    }

    createDraggableBookmarkElement(bookmark) {
        const element = document.createElement('div');
        element.innerHTML = `
            <a href="${bookmark.URL}" target="_blank">${bookmark.Name}</a> - 
            ${bookmark.Description} <span>${bookmark.TagName.join(', ')}</span>`;
        element.dataset.id = bookmark.id;
        element.draggable = true;
        element.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', bookmark.id);
        });
        return element;
    }

    // Load Functions
    async loadDirectories() {
        const directories = await this.fetchDirectories();
        this.dispatch({ type: 'SET_DIRECTORIES', payload: directories });
        this.state.defaultDirectory = directories.find(dir => dir.is_default);
    }

    async loadBookmarks(directoryId) {
        const bookmarks = await this.fetchBookmarks(directoryId);
        this.dispatch({ type: 'SET_BOOKMARKS', payload: bookmarks });
    }

    // Context Menu Handling
    createContextMenu(bookmarkId, event) {
        const contextMenu = document.createElement('div');
        contextMenu.className = 'context-menu';
        contextMenu.innerHTML = `<div>Edit</div><div>Delete</div>`;
        contextMenu.style.position = 'absolute';
        contextMenu.style.left = `${event.pageX}px`;
        contextMenu.style.top = `${event.pageY}px`;
        document.body.appendChild(contextMenu);

        contextMenu.addEventListener('click', (event) => {
            const action = event.target.textContent;
            if (action === 'Edit') {
                this.loadBookmarkForEditing(bookmarkId);
            } else if (action === 'Delete') {
                this.dispatch({ type: 'DELETE_BOOKMARK', payload: bookmarkId });
                this.loadBookmarks(this.state.currentDirectoryId);
            }
            document.body.removeChild(contextMenu);
        });

        document.addEventListener('click', () => {
            document.body.removeChild(contextMenu);
        }, { once: true });
    }

    // Load Bookmark for Editing
    async loadBookmarkForEditing(bookmarkId) {
        const bookmark = await this.fetchBookmark(bookmarkId);
        document.getElementById('edit-title').value = bookmark.Name;
        document.getElementById('edit-url').value = bookmark.URL;
        document.getElementById('edit-description').value = bookmark.Description;
        document.getElementById('edit-tags').value = bookmark.TagName.join(', ');
        document.getElementById('edit-form').style.display = 'block';
    }

    // Form Submission Handling
    async handleFormSubmission(e) {
        e.preventDefault();
        const updatedBookmark = {
            Name: document.getElementById('edit-title').value,
            URL: document.getElementById('edit-url').value,
            Description: document.getElementById('edit-description').value,
            TagName: document.getElementById('edit-tags').value.split(',').map(tag => tag.trim()),
        };
        this.dispatch({ type: 'ADD_BOOKMARK', payload: updatedBookmark });
        this.loadBookmarks(this.state.currentDirectoryId);
        document.getElementById('edit-form').style.display = 'none';
    }
}

// Initialize the BookmarkManager and load directories and bookmarks
const bookmarkManager = new BookmarkManager('http://localhost:3000');
document.addEventListener('DOMContentLoaded', () => {
    bookmarkManager.loadDirectories();
    bookmarkManager.loadBookmarks(bookmarkManager.state.currentDirectoryId);
});

// Handle form submission
document.getElementById('edit-form-content').addEventListener('submit', (e) => bookmarkManager.handleFormSubmission(e));

// Handle context menu
document.addEventListener('contextmenu', (e) => {
    if (e.target.closest('#bookmarks-area')) {
        e.preventDefault();
        const bookmarkId = e.target.dataset.id;
        bookmarkManager.createContextMenu(bookmarkId, e);
    }
});

// Handle drag and drop functionality
document.getElementById('directory-tree').addEventListener('drop', async (e) => {
    e.preventDefault();
    const bookmarkId = e.dataTransfer.getData('text/plain');
    const newDirectoryId = e.target.dataset.id;
    if (newDirectoryId) {
        await bookmarkManager.moveBookmark(bookmarkId, newDirectoryId);
        bookmarkManager.loadBookmarks(newDirectoryId);
    }
});